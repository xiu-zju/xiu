# 应用层

## 2.1 应用层协议原理

### 网络应用的体系结构

可能的应用架构：

- 客户-服务器模式（C/S: client/server）
- 对等模式 (P2P: Peer To Peer)
- 混合体：客户-服务器和对等体系结构

#### 客户-服务器模式

- 服务器:
    - 一直运行
    - 固定的IP地址和周知的端口号（约定）
    - 扩展性：服务器场
        - 数据中心进行扩展
        - **扩展性差**
- 客户端:
    - 主动与服务器通信
    - 与互联网有间歇性的连接
    - 可能是动态 IP 地址
    - 不直接与其它客户端通信

#### 对等体体系结构

- （几乎）没有一直运行的服务器
- 任意端系统之间可以进行通信
- 每一个节点既是客户端又是服务器
- 自扩展性-新peer节点带来新的服务能力，当然也带来新的服务请求
- 参与的主机间歇性连接且可以改变 IP 地址
- 难以管理
- 例子: Gnutella，迅雷

#### C/S 和 P2P 体系结构的混合体

**Napster**

- 文件搜索：集中
    - 主机在中心服务器上注册其资源
    - 主机向中心服务器查询资源位置
- 文件传输：P2P
    - 任意Peer节点之间

**即时通信**

- 在线检测：集中
    - 当用户上线时，向中心服务器注册其IP地址
    - 用户与中心服务器联系，以找到其在线好友的位置
- 两个用户之间聊天：P2P

### 对地址进行编程

- 进程为了接收报文，必须有一个标识，即：SAP（发送也需要标示）
    - 主机：唯一的 32位IP地址
        - 仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很应用进程在运行
    - 所采用的传输层协议：TCP or UDP
    - 端口号（Port Numbers）
- 一些知名端口号的例子：
    - HTTP: TCP 80 Mail: TCP25 ftp:TCP 2
- 一个进程：用IP+port标示 端节点
- 本质上，一对主机进程之间的通信由2个端节点构成

### 传输层提供的服务

- 层间接口必须要携带的信息
    - 要传输的报文（对于本层来说：SDU）
    - 谁传的：自己的应用进程标示：IP+TCP(UDP) 端口
    - 传给谁：对方的应用进程标示：对方的 IP+TCP(UDP) 端口号
- 传输层实体（tcp 或者 udp实体）根据这些信息进行 TCP 报文段（UDP 数据报）的封装
    - 源端口号，目标端口号，数据等
    - 将IP地址往下交IP实体，用于封装IP数据报：源 IP，目标 IP

层间信息的代表

- 如果 Socket API 每次传输报文，都携带如此多
的信息，太繁琐易错，不便于管理
- 用个代号标示通信的双方或者单方：socket
- 就像 OS 打开文件返回的句柄一样
    - 对句柄的操作，就是对文件的操作
- TCP socket：
    - TCP 服务，两个进程之间的通信需要之前要建立连接
        - 两个进程通信会持续一段时间，通信关系稳定
    - 可以用一个整数表示两个应用实体之间的通信关系，本地标示
    - 穿过层间接口的信息量最小
    - TCP socket：源IP，源端口，目标IP，目标IP，目标端口
- UDP socket：
    - UDP服务，两个进程之间的通信需要之前无需建立连接
        - 每个报文都是独立传输的
        - 前后报文可能给不同的分布式进程
    - 因此，只能用一个整数表示本应用实体的标示
        - 因为这个报文可能传给另外一个分布式进程
    - 穿过层间接口的信息大小最小
    - UDP socket：本IP,本端口
    - 但是传输 报文时：必须要提供对方IP，port
        - 接收报文时： 传输层需要上传对方的IP，port

!!! note "TCP socket"
    对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有本地意义的标示。

    Socket ID = f(源IP, 源端口, 目标IP, 目标端口)

!!! note "UDP socket"
    对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有本地意义的标示。

| **特性**             | **TCP Socket**                          | **UDP Socket**                    |
|----------------------|-----------------------------------------|-----------------------------------|
| **层间传递参数**     | 仅整数描述符                            | 整数描述符 + 目标地址（每次发送） |
| **是否维护会话状态** | ✅                                       | ❌                                |
| **适用场景**         | 网页浏览、文件传输                      | DNS查询、视频流、IoT传感器        |
| **设计本质**         | **持久会话的抽象句柄**                  | **数据报端点的抽象标识**          |
| **API特点**      | `connect()`后只需操作Socket描述符，**无需重复指定地址**                  | **每次发送必须指定目标地址**：`sendto(data, (目标IP, 目标端口))`         |

### 应用层协议

- 数据丢失率
    - 有些应用则要求100%的可靠数据传输（如文件）
    - 有些应用（如音频）能容忍一定比例以下的数据丢失
- 延迟
    - 一些应用 出于有效性考虑，对数据传输有严格的时间限制
        - Internet 电话、交互式游戏
        - 延迟、延迟差
- 吞吐
    - 一些应用（如多媒体）必须需要最小限度的吞吐，从而使得应用能够有效运转
    - 一些应用能充分利用可供使用的吞吐(弹性应用)
- 安全性
    - 机密性
    - 完整性
    - 可认证性（鉴别）


| 应用            | 数据丢失率要求     | 吞吐要求                     | 时间敏感性要求          |
|----------------|------------------|----------------------------|-----------------------|
| 文件传输        | 不能丢失          | 弹性（自适应带宽）           | 不敏感（允许延时）     |
| E-mail         | 不能丢失          | 弹性（自适应带宽）           | 不敏感（允许延时）     |
| Web 文档       | 不能丢失          | 弹性（自适应带宽）           | 不敏感（允许延时）     |
| 实时音视频      | 容忍丢失          | 音频：5kbps-1Mbps<br>视频：100kbps-5Mbps | 敏感（<100ms延迟）   |
| 存储音视频      | 容忍丢失          | 音频：5kbps-1Mbps<br>视频：100kbps-5Mbps | 中度敏感（几秒延迟）  |
| 交互式游戏      | 容忍丢失          | 几kbps ~10kbps              | 敏感（<100ms延迟）   |
| 即时讯息        | 不能丢失          | 弹性（自适应带宽）           | 混合型：<br>• 文字：中度敏感（几秒）<br>• 状态更新/通知：敏感（<100ms） |

### Internet 传输层提供的服务

- TCP 服务：
    - 可靠的传输服务
    - 流量控制：发送方不会淹没接受方
    - 拥塞控制：当网络出现拥塞时，能抑制发送方
    - 不能提供的服务：时间保证、最小吞吐保证和安全
    - 面向连接：要求在客户端进程和服务器进程之间建立连接
- UDP 服务：
    - 不可靠数据传输
    - 不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接

### UDP存在的必要性

- 能够**区分不同的进程**，而IP服务不能
    - 在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程
- **无需建立连接**，省去了建立连接时间，适合事务性的应用
- **不做可靠性的工作**，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用
    - 因为为了实现可靠性（准确性、保序等），必须付出时间代价（检错重发）
- 没有拥塞控制和流量控制，应用能够**按照设定的速度发送数据**
    - 而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制

### 安全TCP

- TCP & UDP
    - 都没有加密
    - 明文通过互联网传输，甚至密码
- SSL
    - 在TCP上面实现，提供加密的TCP连接
    - 私密性
    - 数据完整性
    - 端到端的鉴别
- SSL在应用层
    - 应用采用SSL库，SSL库使用TCP通信
- SSL socket API
    - 应用通过API将明文交给socket，SSL将其加密在互联网上传输

## 2.2 Web and HTTP

一些术语:

- Web页：由一些**对象**组成
- 对象可以是HTML文件、JPEG图像、Java小程序、声音剪辑文件等
- Web页含有一个基本的HTML文件，该基本HTML文件又包含若干对象的引用（链接）
- 通过URL对每个对象进行引用
    - 访问协议，用户名，口令字，端口，目录文件等；
- URL格式:

Prot://user:psw@www.someSchool.edu:port/someDept/pic.gif

协议名 用户:口令 主机名 路径名 端口

### HTTP 概况

#### HTTP: **超文本传输协议**

- Web的**应用层**协议
- **客户/服务器**模式
    - 客户: 请求、接收和显示Web对象的浏览器
    - 服务器: 对请求进行响应，发送对象的Web服务器
- HTTP 1.0: RFC 1945
- HTTP 1.1: RFC 2068

#### 使用TCP

- 客户发起一个与服务器的TCP连接 (建立套接字) ，端口号为 80
- 服务器接受客户的TCP连接
- 在浏览器(HTTP客户端)与 Web服务器(HTTP服务器 server)交换HTTP报文 (应用层协议报文)
- TCP连接关闭

#### HTTP是无状态的

- 服务器并不维护关于客户的任何信息

!!! note "维护状态的协议很复杂！"
    - 必须维护历史信息(状态)
    - 如果服务器/客户端死机，它们的**状态信息可能不一致**，二者的信息必须是一致
    - 无状态的服务器能够支持**更多的客户端**

### HTTP 连接

- 非持久 HTTP
    - 最多只有一个对象在TCP连接上发送
    - 下载多个对象需要多个TCP连接
    - HTTP/1.0使用非持久连接
- 持久 HTTP
    - 多个对象可以在一个（在客户端和服务器之间的）TCP连接上传输
    - HTTP/1.1 默认使用持久连接

对于持久 HTTP：

- 非流水方式的持久HTTP：
    - 客户端只能在收到前一个响应后才能发出新的请求
    - 每个引用对象花费一个RTT
- 流水方式的持久HTTP：
    - HTTP/1.1的默认模式
    - 客户端遇到一个引用对象就立即产生一个请求
    - 所有引用（小）对象只花费一个RTT是可能的

### HTTP 请求报文

![](1.png)

![](2.png)

#### 提交表单输入

- Post方式：
    - 网页通常包括表单输入
    - 包含在实体主体(entity body )中的输入被提交到服务器
- URL方式：
    - 方法：GET
    - 输入通过请求行的URL字段上载

