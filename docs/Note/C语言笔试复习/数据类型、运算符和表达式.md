# 2.1 常量与变量

## 2.1.1

* 浮点常数后缀：f或F（单精度浮点数）、l或L（长双精度浮点数）
     **浮点型常数总是有符号的，故没有u和U**
* 整型常数后缀：l或L，u或U，L和U的组合

## 2.1.2 字符型常量

- 普通字符
- 转义字符

| 转义字符 | 含义 |
| :--- | :--- |
| \o | NULL |
| \n | 换行 |
| \r | 回车 |
| \t | 制表 |
| \a | 响铃 |
| \b | 退格 |
| \f | 换页 |
| \\' | 单引号 |
| \\" | 双引号 |
| \\\\ | 反斜杠 |
| \\ddd | 三位8进制 |
| \\xhh | 二位16进制 |

>ddd和hh分别为8进制和16进制的ASCII码

**C语言允许对整型变量赋予字符值，也允许对字符变量赋予整型值**

表示十进制数 -3 的二进制形式使用8位的补码表示。首先，找到3的二进制表示形式，然后取反，并在结果上加1。3 的二进制表示是 `0000 0011`。取反得到 `1111 1100`，然后加1得到补码形式：

\[1111 \ 1100 + 1 = 1111 \ 1101\]

因此，-3 的二进制表示是 `1111 1101`。

|类型|内存|范围|
|:--:|:--:|:--:|
|short int|2|-32768~32767|
|unsign short|2|0~65535|
|int|4|-......~......|
|long int|4|-......~......|

# 2.2 运算符及表达式

[运算符及优先级](https://note.isshikih.top/cour_note/D1QD_CXiaoCheng/#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E5%90%8C%E7%BA%A7%E9%81%B5%E5%BE%AA%E7%BB%93%E5%90%88%E6%96%B9%E5%90%91%E8%A7%84%E5%BE%8B)

在C语言中，如果一个操作数是**整型**，而另一个是**浮点型**，通常会发生**隐式的类型转换**，即整型会被转换为*浮点型*，然后执行浮点数除法。这是因为浮点数的表示范围更广，能够容纳整数和小数。

```c
#include <stdio.h>

int main() {
    int numerator = 7;
    double denominator = 3.0;

    double result = numerator / denominator;  // 整型被转换为浮点型，执行浮点数除法
    printf("%f\n", result);  // 输出 2.333333

    return 0;
}
```

在上面的例子中，`numerator`是整型，`denominator`是浮点型，然后它们相除的结果是一个浮点数。在进行除法运算时，整型的操作数会被自动转换为浮点型，以保留小数部分。

如果你想明确指定整数除法，可以将其中一个操作数强制转换为整型。例如：

```c
#include <stdio.h>

int main() {
    int numerator = 7;
    double denominator = 3.0;

    double result = (double)numerator / denominator;  // 强制将整型转换为浮点型，执行浮点数除法
    printf("%f\n", result);  // 输出 2.333333

    return 0;
}
```

在这个例子中，通过使用`(double)`将`numerator`强制转换为`double`类型，确保了执行的是浮点数除法。

**重点：i++和++i**
在C语言中，`i++` 和 `++i` 都是用来递增变量 `i` 的操作符，但它们有一些关键的区别。

1. **`i++`（后缀递增）：** 这个操作符会先返回 `i` 的当前值，然后再将 `i` 的值加 1。所以，如果你写 `y = i++`，`y` 将会得到 `i` 的当前值，然后 `i` 的值会递增。

    ```c
    #include <stdio.h>

    int main() {
        int i = 5;
        int y = i++;

        printf("i: %d\n", i);  // 输出：6
        printf("y: %d\n", y);  // 输出：5

        return 0;
    }
    ```

2. **`++i`（前缀递增）：** 这个操作符会先将 `i` 的值加 1，然后再返回 `i` 的新值。所以，如果你写 `y = ++i`，`y` 将会得到 `i` 的递增后的新值。

    ```c
    #include <stdio.h>

    int main() {
        int i = 5;
        int y = ++i;

        printf("i: %d\n", i);  // 输出：6
        printf("y: %d\n", y);  // 输出：6

        return 0;
    }
    ```

在大多数情况下，两者的效果是相同的，但在某些特定的场景中，选择使用其中之一可能更合适。例如，在表达式中，`++i` 的效率可能比 `i++` 高，**因为它不需要保存 `i` 的当前值**。

在更复杂的情况下，了解递增操作符的前缀和后缀形式之间的区别是很重要的。以下是一些可能更具挑战性的示例，以帮助说明这两者之间的区别：

1. **在表达式中使用：**

    ```c
    #include <stdio.h>

    int main() {
        int i = 5;
        int x = 2 * i++;  // 后缀递增

        printf("i: %d\n", i);  // 输出：6
        printf("x: %d\n", x);  // 输出：10

        return 0;
    }
    ```

    上述示例中，`x = 2 * i++` 表示先使用 `i` 的当前值计算 `2 * i`，然后再递增 `i` 的值。

2. **循环中的使用：**

    ```c
    #include <stdio.h>

    int main() {
        int i;

        printf("Postfix increment:\n");
        for (i = 0; i < 5; i++) {
            printf("%d ", i);
        }
        printf("\n");

        printf("Prefix increment:\n");
        for (i = 0; i < 5; ++i) {
            printf("%d ", i);
        }
        printf("\n");

        return 0;
    }
    ```

    在循环中使用时，`i++` 和 `++i` 在效果上是相同的，都会递增 `i` 的值，但前缀递增可能在某些情况下更受欢迎，因为它不需要维护 `i` 的当前值。


**逗号运算符**
从左到右执行，最后返回最后表达式的值。

# 2.3 位运算

| 操作 | 符号 | 解释 | 示例 |
| ---- | ---- | ---- | ---- |
| 与运算 | & | 对应位上的两个二进制数都为1时，结果的相应位为1，否则为0。 | 1010 & 1100 = 1000 |
| 或运算 | \| | 对应位上的两个二进制数有一个为1时，结果的相应位为1。 | 1010 \| 1100 = 1110 |
| 异或运算 | ^ | 对应位上的两个二进制数不同时，结果的相应位为1，相同时为0。 | 1010 ^ 1100 = 0110 |
| 取反运算 | ~ | 将每个位上的0变为1，1变为0。 | ~1010 = 0101 |
| 左移运算 | << | 将二进制数的所有位向左移动n位，右侧用0填充。 | 1010 << 2 = 00101000 |
| 右移运算 | >> | 将二进制数的所有位向右移动n位，左侧用符号位或0填充。 | 1010 >> 2 = 00001010 |

<< 向左n位，则乘2^n。

若知道负数的补码，则除符号位取反加一（再加负号）。

它用于将一个二进制数的各位向右移动指定的位数。右移运算会用符号位填充左侧的空位（对于有符号整数），或者用0填充（对于无符号整数）。

![[Pasted image 20231226220150.jpg]]

# 做题总结

%运算符的操作对象为整数，赋值运算左边是变量，右边为表达式

宏定义中为常量，不能进行自增操作
```C
#define d 2
d++; //错误的
```

关于e的多少次方，阶数必须为**一到三位无符号常量**，不能为空，且e/E前面的部分**不可完全省去**。

y=double(i)是错误的
y=(double)i是正确的