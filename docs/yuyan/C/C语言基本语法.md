# 1.1标识符

## 1.1.1标识符的组成规则

1. 必须由字母、数字和下划线组成
2. 第一个字符必须是**字母或下划线**
3. 字母要区分大小写
4. 不能与关键字同名

## 1.1.2有效长度

前31个字符

## 1.1.3关键字
Which one below is NOT a keyword of the C programming language? ____	
A. define	
B. if
C. typedef
D. while

>A `define` 不是关键字，是预处理指令，你甚至可以 `int define;` 而 `if`、`typedef`、`while` 显然都是关键字。

Which one below is NOT a valid identifier in the C programming language? ____ 
A. printf
B.  \_ever
C. "char"
D. true

>  C，因为 `int "char";` 肯定是非法的，标识符**必须以字母或下划线开头**。对于 A，printf 只是一个函数名，不是关键字，所以是合法的。对于 D，C 语言中 true 并不是关键字，也可以使用。
# 1.2输入与输出

## 1.2.1 printf

**转化声明符**

|类型|格式字符串|输出形式|
|:--|:--|:--|
|整形|%d|带符号的十进制|
|整型|%o|无符号的八进制|
|整型|%x|无符号的十六进制|
|整型|%u|无符号的十进制|
|浮点型|%f|小数，6位|
|浮点型|%e|指数，6位|
|浮点型|%g|优化的小数（去掉无意义的0）|
|字符型|%c|字符|
|字符型|%s|字符串|

附加格式

|字符|输出|
|:--|:--|
|%md|当数据长度<m时，左补空格，否则按实际输出 ^1|
|%nf|指定小数点后位数（四舍五入）|
|%ns|对字符串，输出指定位数|
|%-md|输入数据在域内左对齐|
|%+md|在有符号的正数前加正号|
|%0md|在左边的空格用0补|
|%#o|在八进制前显示0|
|%#x|在十六进制前显示0x|
|%ld|在d,o,x,u前，long型|
|%lf|在e,f,g前，double型|

**重点**

关于%e的用法

在C语言中，`%e`是用于格式化输出浮点数的格式控制符。它表示以指数形式输出浮点数，使用小写字母"e"表示指数部分。具体来说，`%e`将浮点数表示为`[-]d.ddddde±dd`的形式，其中第一个`d`是整数部分，后面的小数部分以及指数部分都用小写字母"e"表示。

以下是一个简单的例子：

```c
#include <stdio.h>

int main() {
    double number = 12345.6789;
    printf("Number in scientific notation: %e\n", number);
    return 0;
}
```

这个程序将输出：

```
Number in scientific notation: 1.234568e+004
```

在这个例子中，`%e`将`12345.6789`格式化为科学计数法形式，即`1.234568e+04`。指数部分表示10的幂，因此`e+04`表示10的4次方。

%e也可以与其他格式字符串的语法相结合

```C
printf("%12.3e",918.48);
```

这将会输出

`  9.185e+002`

`printf("%12.3e", 918.48)` 是一个格式化输出语句，它使用了 `%e` 格式控制符来表示浮点数，并且包含了一些宽度和精度的设置。让我们逐个解释这个语句：

- `%e`: 表示以科学计数法的形式输出浮点数。
- `%12.3e`: 这个部分中的数字控制了输出的格式。
  - `12`: 表示输出的总宽度为12个字符，包括小数点和指数部分。
  - `.3`: 表示输出的小数部分精确到3位。
  - `e`: 表示使用科学计数法表示浮点数。

现在，让我们应用这些设置到 `918.48` 这个浮点数：

1. 浮点数 `918.48` 以科学计数法表示为 `9.1848e+02`。
2. 总宽度为12个字符，所以在输出中会填充一些空格，使得整个输出占据12个字符的宽度。
3. 小数部分精确到3位，所以输出的小数部分是 `.185`。
4. 最终输出为 `"  9.185e+002"`。

这样，`printf("%12.3e", 918.48)` 将会输出 `"   9.185e+002"`。

## 1.2.2 scanf

```C
scanf("%4d%2d",&a,&b);
```

若输入123456，则a=1234，b=56

```C
//若在%后有*说明符，则表示本次输入不传给任意值
scanf("%2d%*3d%2d",&a,&b);
```

若输入1234567
则a=12，b=67

```C
scanf("%.2f",&a);
```

不合法

```C
scanf("%[^m]",&a);
```

非常厉害，m是任意一个字符，一直读到m字符为止。

# 本章做题分析

class不可以用作用户标识符，因为他是C++中的关键字

```C
scanf("a=%d,b=%d",&a,&b);
```
这条语句是合法的

include 不是C语言中的关键字

```C
int a = 1234;
printf("%2d",a);
```

此时输出的是1234，因为[[#^1]]

```C
int a,b,c;
a=b=c=5;
```

这是合法的。而
```C
int a=b=c=5;
```
这是不合法的。