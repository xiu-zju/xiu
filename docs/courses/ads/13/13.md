# Randomized Algorithms

- 为何采取随机化算法？
- 优化复杂度（避免被刻意构造的数据）
- 获得一个非精确解（还记得local search吗）
- ……

## The Hiring Problem
$n$个人依次来面试，每个人都有能力值$q_i$。面试一个人花费$C_i$，对一个人的签订费是$C_h$。目标是尽可能少花费，雇下能力值最高的人。

假设M个人被雇佣了，那么cost是$O(NC_i+MC_h)$。

### Naive Solution
```c
int Hiring ( EventType C[ ], int N )
{   /* candidate 0 is a least-qualified dummy candidate */
    int Best = 0;
    int BestQ = the quality of candidate 0;
    for ( i=1; i<=N; i++ ) {
        Qi = interview( i ); /* Ci */
        if ( Qi > BestQ ) {
            BestQ = Qi;
            Best = i;
            hire( i );  /* Ch */
        }
    }
    return Best;
}
```
- 最坏情况是能力值单调递增，cost是$O(NC_h)$。（忽略$C_i$，因为比较小）
- 如果是random，分析如下：
    ![alt text](<./image/CleanShot 2024-12-10 at 11.03.35@2x.png>)

### Randomized Algorithm
```c
int RandomizedHiring ( EventType C[ ], int N )
{   /* candidate 0 is a least-qualified dummy candidate */
    int Best = 0;
    int BestQ = the quality of candidate 0;

    randomly permute the list of candidates;

    for ( i=1; i<=N; i++ ) {
        Qi = interview( i ); /* Ci */
        if ( Qi > BestQ ) {
            BestQ = Qi;
            Best = i;
            hire( i );  /* Ch */
        }
    }
}
```

#### Randomized Permutation Algorithm
```c
void PermuteBySorting ( ElemType A[ ], int N )
{
    for ( i=1; i<=N; i++ )
        A[i].P = 1 + rand() % (N^3); 
        /* makes it more likely that all priorities are unique */
    Sort A, using P as the sort keys;
}
```

### Online Hiring Algorithm
前 $k$ 个人一概不签。从第 $k + 1$ 个人开始，只要比之前的人都强就签下。
```C
int OnlineHiring ( EventType C[ ], int N, int k)
{
    int Best = N;
    int BestQ = -  ;
    for ( i=1; i<=k; i++ ) {
        Qi = interview( i );
        if ( Qi > BestQ )   BestQ = Qi;
    }
    for ( i=k+1; i<=N; i++ ) {
        Qi = interview( i );
        if ( Qi > BestQ ) {
            Best = i;
            break;
        }
    }
    return Best;
}
```